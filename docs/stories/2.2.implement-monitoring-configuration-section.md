# Story 2.2: Implement Monitoring Configuration Section

## Status
**Approved**

## Story
**As a** user,
**I want** to configure the ping target and interval,
**so that** I can monitor my specific network conditions.

## Acceptance Criteria

| # | Criteria |
|---|----------|
| AC1 | Dropdown selector for ping target with pre-defined options (see table below) |
| AC2 | Input field for ping interval (seconds) with min/max validation (1-60s) |
| AC3 | Default values: target `Google DNS (8.8.8.8)`, interval `5` seconds |
| AC4 | Changes saved on selection/blur |
| AC5 | "Restore Defaults" button resets monitoring settings |
| AC6 | Toast notification confirms settings saved |

**Pre-defined Ping Targets (Dropdown Options):**

| Label | Value | Protocol | Rationale |
|-------|-------|----------|-----------|
| Google DNS (8.8.8.8) | `8.8.8.8` | ICMP/HTTP | Most reliable, global presence |
| Cloudflare DNS (1.1.1.1) | `1.1.1.1` | ICMP/HTTP | Known for low latency |
| Quad9 DNS (9.9.9.9) | `9.9.9.9` | ICMP/HTTP | Security-focused alternative |
| OpenDNS (208.67.222.222) | `208.67.222.222` | ICMP/HTTP | Popular enterprise choice |
| Google Web | `www.google.com` | HTTP HEAD | Web-based measurement |
| Cloudflare Web | `www.cloudflare.com` | HTTP HEAD | Web-based alternative |

## Integration Verification

| # | Verification |
|---|--------------|
| IV1 | Dropdown displays all pre-defined targets correctly |
| IV2 | Saved settings persist after app restart |
| IV3 | Monitor tab uses new settings when monitoring restarted |
| IV4 | Rust backend accepts all whitelisted targets (test each of the 6 targets via Monitor tab) |

## Tasks / Subtasks

- [ ] Task 1: Define Ping Target Options Constant (AC: 1, 3)
  - [ ] 1.1 Create file `netmonitor/src/app/models/ping-targets.constant.ts`
  - [ ] 1.2 Define `PingTargetOption` interface: `{ label: string; value: string }`
  - [ ] 1.3 Define `PING_TARGET_OPTIONS` constant array with all 6 options from Epic table
  - [ ] 1.4 Export both interface and constant
  - [ ] 1.5 Add JSDoc documentation

- [ ] Task 2: Update SettingsPage Component with Form (AC: 1, 2, 3, 4)
  - [ ] 2.1 Add imports: `CommonModule`, `FormsModule`, `ReactiveFormsModule` to `settings.page.ts`
  - [ ] 2.2 Inject `SettingsService` using `inject()` pattern
  - [ ] 2.3 Inject `ToastController` from `@ionic/angular` using `inject()`
  - [ ] 2.4 Add property `settings$` from `SettingsService.settings$`
  - [ ] 2.5 Add property `pingTargetOptions = PING_TARGET_OPTIONS`
  - [ ] 2.6 Add property `selectedTarget: string` (initialized from settings)
  - [ ] 2.7 Add property `pingInterval: number` (initialized from settings)
  - [ ] 2.8 Implement `ngOnInit()` to subscribe to `settings$` and initialize local state
  - [ ] 2.9 Implement `onTargetChange(value: string)` method that calls `updateMonitoringConfig()`
  - [ ] 2.10 Implement `onIntervalChange(value: number)` method with validation (clamp 1-60)
  - [ ] 2.11 Add `ngOnDestroy()` to unsubscribe

- [ ] Task 3: Implement Toast Notification (AC: 6)
  - [ ] 3.1 Create private `async showSavedToast()` method
  - [ ] 3.2 Use `ToastController.create()` with options: message "Settings saved", duration 1500ms, position "bottom", color "success"
  - [ ] 3.3 Call `toast.present()` after creating
  - [ ] 3.4 Call `showSavedToast()` after successful save in both change handlers

- [ ] Task 4: Implement Restore Defaults (AC: 5)
  - [ ] 4.1 Import `DEFAULT_SETTINGS` from `settings.interface.ts`
  - [ ] 4.2 Implement `async restoreDefaults()` method
  - [ ] 4.3 Call `settingsService.updateMonitoringConfig(DEFAULT_SETTINGS.monitoringConfig)`
  - [ ] 4.4 Show toast with message "Defaults restored"

- [ ] Task 5: Create Settings Page Template (AC: 1, 2, 5)
  - [ ] 5.1 Update `settings.page.html` with `<ion-header>` containing title "Settings"
  - [ ] 5.2 Add `<ion-content class="ion-padding">`
  - [ ] 5.3 Add `<ion-list>` with `<ion-list-header>Monitoring Configuration</ion-list-header>`
  - [ ] 5.4 Add `<ion-item>` with `<ion-select>` for ping target:
    - Label: "Ping Target"
    - `[(ngModel)]="selectedTarget"`
    - `(ionChange)="onTargetChange($event.detail.value)"`
    - `<ion-select-option>` for each target in `pingTargetOptions`
  - [ ] 5.5 Add `<ion-item>` with `<ion-input>` for ping interval:
    - Label: "Ping Interval (seconds)"
    - `type="number"` `min="1"` `max="60"`
    - `[(ngModel)]="pingInterval"`
    - `(ionBlur)="onIntervalChange(pingInterval)"`
  - [ ] 5.6 Add `<ion-note>` below interval input: "Valid range: 1-60 seconds"
  - [ ] 5.7 Add `<ion-button>` for "Restore Defaults":
    - `expand="block"` `color="medium"` `class="ion-margin-top"`
    - `(click)="restoreDefaults()"`

- [ ] Task 6: Add Page-Specific Styles (AC: UI polish)
  - [ ] 6.1 Update `settings.page.scss` with:
    - `.ion-margin-top { margin-top: 16px; }`
    - Any additional spacing/theming needed

- [ ] Task 7: Refactor Rust Backend Whitelist Validation (AC: IV4)
  - [ ] 7.1 Open `netmonitor/src-tauri/src/lib.rs`
  - [ ] 7.2 Locate the `ping` command function and existing `ALLOWED_DOMAIN` constant
  - [ ] 7.3 **CRITICAL:** Replace single `ALLOWED_DOMAIN: &str` with array `ALLOWED_TARGETS: [&str; 6]`
  - [ ] 7.4 **CRITICAL:** Refactor validation from `url.contains(ALLOWED_DOMAIN)` to `ALLOWED_TARGETS.contains(&url.as_str())` - current `contains()` logic does NOT work for IP addresses
  - [ ] 7.5 Allowed targets array: `["8.8.8.8", "1.1.1.1", "9.9.9.9", "208.67.222.222", "www.google.com", "www.cloudflare.com"]`
  - [ ] 7.6 Update error message to: `format!("Target '{}' not in whitelist", url)`
  - [ ] 7.7 Update tests if needed for whitelist behavior

- [ ] Task 8: Write Unit Tests for SettingsPage (AC: 1, 2, 4, 5, 6)
  - [ ] 8.1 Update `netmonitor/src/app/settings/settings.page.spec.ts`
  - [ ] 8.2 Test: Should initialize with settings from SettingsService
  - [ ] 8.3 Test: `onTargetChange()` calls `settingsService.updateMonitoringConfig()` with new target
  - [ ] 8.4 Test: `onIntervalChange()` clamps value to 1-60 range
  - [ ] 8.5 Test: `onIntervalChange()` calls `settingsService.updateMonitoringConfig()` with clamped interval
  - [ ] 8.6 Test: `restoreDefaults()` calls `updateMonitoringConfig()` with DEFAULT_SETTINGS.monitoringConfig
  - [ ] 8.7 Test: `showSavedToast()` creates toast with correct options
  - [ ] 8.8 Mock `ToastController` with `create` returning `{ present: vi.fn() }`

- [ ] Task 9: Verify Regression and Integration (IV: 1-4)
  - [ ] 9.1 Run existing test suite: `npm test` - all tests pass
  - [ ] 9.2 Manual verification: Navigate to Settings tab
    - [ ] 9.2.1 Verify dropdown shows all 6 target options
    - [ ] 9.2.2 Verify interval input with validation
    - [ ] 9.2.3 Verify toast appears on save
    - [ ] 9.2.4 Verify Restore Defaults works
  - [ ] 9.3 Manual verification: Settings persistence
    - [ ] 9.3.1 Change target to Cloudflare DNS
    - [ ] 9.3.2 Restart app
    - [ ] 9.3.3 Verify Settings tab shows Cloudflare DNS selected
  - [ ] 9.4 Manual verification: Monitor integration
    - [ ] 9.4.1 Change ping interval to 10 seconds
    - [ ] 9.4.2 Go to Monitor tab and start monitoring
    - [ ] 9.4.3 Verify pings occur at ~10 second intervals
  - [ ] 9.5 Lint check: `npm run lint` passes

## Dev Notes

### Previous Story Insights (Story 2.1)
[Source: docs/stories/2.1.create-settings-service-and-data-model.md#dev-agent-record]

- `SettingsService` is fully implemented with:
  - `settings$` Observable for reactive access
  - `getCurrentSettings()` for synchronous access
  - `updateMonitoringConfig(config: Partial<MonitoringConfig>)` for persistence
- Fire-and-forget pattern for persistence (no await needed in UI handlers)
- `MonitorService` already reads from settings via getters (`pingTarget`, `pingIntervalMs`)
- Settings loaded at app startup via APP_INITIALIZER

### SettingsService API Reference
[Source: netmonitor/src/app/services/settings.service.ts]

```typescript
@Injectable({ providedIn: 'root' })
export class SettingsService {
  readonly settings$: Observable<AppSettings>;

  getCurrentSettings(): AppSettings;
  async updateMonitoringConfig(config: Partial<MonitoringConfig>): Promise<void>;
}
```

**Usage in Component:**
```typescript
private readonly settingsService = inject(SettingsService);

// Subscribe to reactive updates
this.settingsService.settings$.subscribe(settings => {
  this.selectedTarget = settings.monitoringConfig.pingTarget;
  this.pingInterval = settings.monitoringConfig.pingInterval;
});

// Save changes (fire-and-forget pattern is safe)
this.settingsService.updateMonitoringConfig({ pingTarget: newTarget });
```

### MonitoringConfig Interface
[Source: netmonitor/src/app/models/settings.interface.ts]

```typescript
export interface MonitoringConfig {
  pingTarget: string;    // Target host/URL (e.g., '8.8.8.8')
  pingInterval: number;  // Polling interval in seconds
}

export const DEFAULT_SETTINGS: AppSettings = {
  monitoringConfig: {
    pingTarget: '8.8.8.8',  // Google DNS (default)
    pingInterval: 5          // 5 seconds
  },
  // ... other sections
};
```

### Ionic Components Reference
[Source: https://ionicframework.com/docs/components]

**Ion-Select (Dropdown):**
```html
<ion-item>
  <ion-select label="Ping Target" [(ngModel)]="selectedTarget"
              (ionChange)="onTargetChange($event.detail.value)">
    <ion-select-option *ngFor="let opt of pingTargetOptions" [value]="opt.value">
      {{ opt.label }}
    </ion-select-option>
  </ion-select>
</ion-item>
```

**Ion-Input (Number):**
```html
<ion-item>
  <ion-input label="Ping Interval (seconds)" type="number"
             min="1" max="60" [(ngModel)]="pingInterval"
             (ionBlur)="onIntervalChange(pingInterval)">
  </ion-input>
</ion-item>
```

**ToastController:**
```typescript
import { ToastController } from '@ionic/angular';

private readonly toastController = inject(ToastController);

async showSavedToast(): Promise<void> {
  const toast = await this.toastController.create({
    message: 'Settings saved',
    duration: 1500,
    position: 'bottom',
    color: 'success'
  });
  await toast.present();
}
```

### Ping Targets Constant Structure
[Source: Epic 2, Story 2.2 - Pre-defined targets]

```typescript
// netmonitor/src/app/models/ping-targets.constant.ts

/** Option for ping target dropdown */
export interface PingTargetOption {
  /** Display label shown to user */
  label: string;
  /** Actual value used for pinging */
  value: string;
}

/** Pre-defined ping target options for dropdown */
export const PING_TARGET_OPTIONS: PingTargetOption[] = [
  { label: 'Google DNS (8.8.8.8)', value: '8.8.8.8' },
  { label: 'Cloudflare DNS (1.1.1.1)', value: '1.1.1.1' },
  { label: 'Quad9 DNS (9.9.9.9)', value: '9.9.9.9' },
  { label: 'OpenDNS (208.67.222.222)', value: '208.67.222.222' },
  { label: 'Google Web', value: 'www.google.com' },
  { label: 'Cloudflare Web', value: 'www.cloudflare.com' }
];
```

### Standalone Component Pattern
[Source: architecture/coding-standards.md]

```typescript
@Component({
  selector: 'app-settings',
  templateUrl: 'settings.page.html',
  styleUrls: ['settings.page.scss'],
  standalone: true,
  imports: [CommonModule, FormsModule, IonicModule]
})
export class SettingsPage implements OnInit, OnDestroy {
  private readonly settingsService = inject(SettingsService);
  private readonly toastController = inject(ToastController);

  pingTargetOptions = PING_TARGET_OPTIONS;
  selectedTarget = '';
  pingInterval = 5;

  private subscription: Subscription | null = null;

  ngOnInit(): void {
    this.subscription = this.settingsService.settings$.subscribe(settings => {
      this.selectedTarget = settings.monitoringConfig.pingTarget;
      this.pingInterval = settings.monitoringConfig.pingInterval;
    });
  }

  ngOnDestroy(): void {
    this.subscription?.unsubscribe();
  }
}
```

### Input Validation Pattern
[Source: Epic 2 AC2 - min/max validation]

```typescript
async onIntervalChange(value: number): Promise<void> {
  // Clamp to valid range
  const clamped = Math.max(1, Math.min(60, value));

  // Update local state if clamped
  if (clamped !== value) {
    this.pingInterval = clamped;
  }

  await this.settingsService.updateMonitoringConfig({ pingInterval: clamped });
  await this.showSavedToast();
}
```

### Rust Backend Whitelist Pattern
[Source: netmonitor/src-tauri/src/lib.rs]

**Current code (MUST BE REFACTORED):**
```rust
// Current implementation - only allows www.google.com
const ALLOWED_DOMAIN: &str = "www.google.com";

#[tauri::command]
async fn ping(url: String, state: State<'_, AppState>) -> Result<PingResult, String> {
    // PROBLEM: url.contains() does NOT work for IP addresses like "8.8.8.8"
    if !url.contains(ALLOWED_DOMAIN) {
        return Err(format!("Security Violation: URL must target {}", ALLOWED_DOMAIN));
    }
    // ... rest of ping logic
}
```

**Required refactoring:**
```rust
// Whitelist of allowed ping targets (IPs and domains)
const ALLOWED_TARGETS: [&str; 6] = [
    "8.8.8.8",
    "1.1.1.1",
    "9.9.9.9",
    "208.67.222.222",
    "www.google.com",
    "www.cloudflare.com"
];

#[tauri::command]
async fn ping(url: String, state: State<'_, AppState>) -> Result<PingResult, String> {
    // Use array membership check instead of contains()
    if !ALLOWED_TARGETS.contains(&url.as_str()) {
        return Err(format!("Target '{}' not in whitelist", url));
    }
    // ... rest of ping logic unchanged
}
```

### Source Tree - Files to Create
[Source: architecture/source-tree-and-module-organization.md]

```
netmonitor/src/app/
└── models/
    └── ping-targets.constant.ts   # Ping target options (NEW)
```

### Source Tree - Files to Modify
[Source: architecture/enhancement-impact-analysis.md]

```
netmonitor/src/app/
├── settings/
│   ├── settings.page.ts           # Add form logic, SettingsService integration
│   ├── settings.page.html         # Add dropdown, input, button
│   ├── settings.page.scss         # Add styling
│   └── settings.page.spec.ts      # Add unit tests
└── src-tauri/src/
    └── lib.rs                     # Add target whitelist validation
```

## Testing

### Test File Location
[Source: architecture/source-tree-and-module-organization.md]

- Test file: `netmonitor/src/app/settings/settings.page.spec.ts` (existing placeholder)

### Testing Framework
[Source: architecture/testing-strategy.md]

- **Test Runner:** Vitest (via `@angular/build:unit-test`)
- **Browser Mode:** Chromium via Playwright
- **Commands:** `npm test` or `ng test --browsers=chromium`

### Test Structure Pattern
[Source: architecture/coding-standards.md#unit-test-structure]

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { TestBed } from '@angular/core/testing';
import { SettingsPage } from './settings.page';
import { SettingsService } from '../services/settings.service';
import { ToastController } from '@ionic/angular';
import { BehaviorSubject } from 'rxjs';
import { DEFAULT_SETTINGS, AppSettings } from '../models/settings.interface';

describe('SettingsPage', () => {
  let component: SettingsPage;
  let mockSettingsService: {
    settings$: BehaviorSubject<AppSettings>;
    updateMonitoringConfig: ReturnType<typeof vi.fn>;
  };
  let mockToastController: {
    create: ReturnType<typeof vi.fn>;
  };

  beforeEach(async () => {
    mockSettingsService = {
      settings$: new BehaviorSubject<AppSettings>(DEFAULT_SETTINGS),
      updateMonitoringConfig: vi.fn().mockResolvedValue(undefined)
    };

    const mockToast = { present: vi.fn().mockResolvedValue(undefined) };
    mockToastController = {
      create: vi.fn().mockResolvedValue(mockToast)
    };

    await TestBed.configureTestingModule({
      imports: [SettingsPage],
      providers: [
        { provide: SettingsService, useValue: mockSettingsService },
        { provide: ToastController, useValue: mockToastController }
      ]
    }).compileComponents();

    const fixture = TestBed.createComponent(SettingsPage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should initialize with settings from SettingsService', () => {
    expect(component.selectedTarget).toBe('8.8.8.8');
    expect(component.pingInterval).toBe(5);
  });

  it('should clamp interval to valid range', async () => {
    await component.onIntervalChange(100);
    expect(mockSettingsService.updateMonitoringConfig)
      .toHaveBeenCalledWith({ pingInterval: 60 });
  });
});
```

### Coverage Target
[Source: architecture/testing-strategy.md]

- **Target:** 80% coverage on new component methods
- **Command:** `ng test --coverage`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-22 | 0.1 | Initial draft created from Epic 2 | Scrum Master |
| 2025-12-22 | 0.2 | PO validation fixes: expanded Task 7 for Rust refactoring, clarified IV4, added QA Results section | Product Owner |

---

## Dev Agent Record

*(To be filled by Dev Agent during implementation)*

### Agent Model Used

### Debug Log References

### Completion Notes

### File List

---

## QA Results

*(To be filled by QA Agent after implementation review)*
