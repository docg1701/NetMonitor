# Story 1.3: Integrate Ping Persistence into MonitorService

## Status
**Done**

## Story
**As a** user,
**I want** my ping results automatically saved to the database,
**so that** I can view historical data and generate reports later.

## Acceptance Criteria

| # | Criteria |
|---|----------|
| AC1 | Each ping result is persisted to SQLite immediately after measurement |
| AC2 | Database writes are non-blocking (don't delay next ping) |
| AC3 | Failed database writes are logged but don't stop monitoring |
| AC4 | Ping results include all fields: timestamp, latency_ms, success (boolean), target |
| AC5 | Historical data survives app restart |

## Integration Verification

| # | Verification |
|---|--------------|
| IV1 | Real-time chart continues updating at same refresh rate |
| IV2 | Memory usage remains stable (no accumulation from DB operations) |
| IV3 | App startup time not significantly impacted (<500ms additional) |

## Tasks / Subtasks

- [x] Task 1: Create PingRepository Service (AC: 1, 3, 4)
  - [x] 1.1 Create file `netmonitor/src/app/services/ping.repository.ts`
  - [x] 1.2 Inject `DatabaseService` using `inject()` pattern
  - [x] 1.3 Implement `savePing(result: PingResult, target: string): Promise<void>` method
    - [x] 1.3.1 Convert `PingResult` to database row format:
      - `timestamp`: `result.timestamp.getTime()` (Unix timestamp in ms)
      - `latency_ms`: `result.latencyMs` (REAL, nullable)
      - `success`: `result.status === 'ok' ? 1 : 0` (INTEGER)
      - `target`: target string parameter
    - [x] 1.3.2 Use parameterized INSERT: `INSERT INTO pings (timestamp, latency_ms, success, target) VALUES (?, ?, ?, ?)`
  - [x] 1.4 Implement error handling within `savePing()`:
    - [x] 1.4.1 Check `databaseService.isInitialized` at start - return early if false
    - [x] 1.4.2 Wrap database call in try/catch
    - [x] 1.4.3 Log errors with `console.error('Failed to persist ping:', err)`
    - [x] 1.4.4 Never throw - always resolve (errors logged, not propagated)
  - [x] 1.5 Add JSDoc documentation for public methods

- [x] Task 2: Integrate PingRepository into MonitorService (AC: 1, 2)
  - [x] 2.1 Inject `PingRepository` into `MonitorService` using `inject()` pattern
  - [x] 2.2 Modify the subscribe block in `startMonitoring()` to call `savePing()` after updating results
  - [x] 2.3 Implement non-blocking persistence (fire-and-forget pattern):
    - Call `savePing()` without `await`
    - No `.catch()` needed - PingRepository handles errors internally
    - Example: `this.pingRepository.savePing(result, this.pingUrl);`

- [x] Task 3: Write Unit Tests for PingRepository (AC: 1, 3, 4)
  - [x] 3.1 Create `netmonitor/src/app/services/ping.repository.spec.ts`
  - [x] 3.2 Test: `savePing()` calls `DatabaseService.execute()` with correct SQL and params
  - [x] 3.3 Test: `savePing()` converts timestamp to Unix epoch correctly
  - [x] 3.4 Test: `savePing()` converts success status to 1/0 INTEGER
  - [x] 3.5 Test: `savePing()` handles null latencyMs for error results
  - [x] 3.6 Test: `savePing()` catches and logs database errors (doesn't throw)
  - [x] 3.7 Test: `savePing()` returns early when database not initialized (no execute call)

- [x] Task 4: Write Integration Tests for MonitorService Persistence (AC: 2, 3)
  - [x] 4.1 Update `netmonitor/src/app/services/monitor.service.spec.ts`
  - [x] 4.2 Test: Monitoring emits results via `results$` regardless of database state
  - [x] 4.3 Test: `savePing()` is called after each ping result
  - [x] 4.4 Test: Database errors don't stop monitoring (verify `results$` continues emitting)
  - [x] 4.5 Test: Ping timing is not affected by database write (non-blocking verification)

- [x] Task 5: Verify Regression - Existing Functionality (IV: 1, 2, 3)
  - [x] 5.1 Run existing test suite: `npm test` - all tests pass (84/84 tests passing)
  - [x] 5.2 Verify in browser: app builds and runs without database (WebDatabaseService no-op) (IV1)
  - [x] 5.3 Manual verification: chart updates at expected rate (2 second default interval) (IV1)
  - [x] 5.4 Tauri verification: Build and run desktop app, confirm pings are persisted (AC5)
    - [x] 5.4.1 Run app for 30+ seconds
    - [x] 5.4.2 Stop app
    - [x] 5.4.3 Verify data persists by checking database file or restarting app
  - [x] 5.5 Lint check: `npm run lint` passes

## Dev Notes

### Previous Story Insights (Story 1.2)
[Source: docs/stories/1.2.implement-sqlite-schema-and-migrations.md#dev-agent-record]

- MigrationService exists and runs on app startup via `APP_INITIALIZER`
- V1 migration creates `pings` table with columns: `id`, `timestamp`, `latency_ms`, `success`, `target`
- V1 migration creates `settings` table with columns: `key`, `value`
- Index exists on `pings.timestamp` for query performance
- DatabaseService abstract class provides: `init()`, `execute()`, `select()`, `close()`, `isInitialized$`, `isInitialized`
- Platform detection uses `isTauri()` from `@tauri-apps/api/core` for Tauri detection
- Three implementations: TauriDatabaseService (real), CapacitorDatabaseService (real), WebDatabaseService (no-op stub)
- WebDatabaseService is a no-op - `execute()` resolves immediately, `select()` returns empty arrays
- Bug fix applied: NVIDIA GPU blank screen (WEBKIT_DISABLE_DMABUF_RENDERER=1)
- Bug fix applied: Angular 21 build output path (`frontendDist: "../www/browser"`)
- Bug fix applied: Mold linker config in `src-tauri/.cargo/config.toml`

### Source Tree - Files to Create
[Source: architecture/source-tree-and-module-organization.md, architecture/enhancement-impact-analysis.md]

```
netmonitor/src/app/services/
├── ping.repository.ts           # Ping persistence service (NEW)
└── ping.repository.spec.ts      # Unit tests (NEW)
```

### Source Tree - Files to Modify
[Source: architecture/enhancement-impact-analysis.md]

```
netmonitor/src/app/services/
└── monitor.service.ts           # Add PingRepository injection, persist pings
└── monitor.service.spec.ts      # Update tests for persistence integration
```

### Data Models - Schema Reference
[Source: architecture/data-models-and-schema.md#database-tables]

**pings table (already created by V1 migration):**
| Column | Type | Description | Mapping from PingResult |
|--------|------|-------------|-------------------------|
| id | INTEGER | Primary key, auto-increment | Auto-generated |
| timestamp | INTEGER | Unix timestamp (ms) | `result.timestamp.getTime()` |
| latency_ms | REAL | Latency in milliseconds (nullable) | `result.latencyMs` |
| success | INTEGER | 1 = ok, 0 = error | `result.status === 'ok' ? 1 : 0` |
| target | TEXT | Ping destination address | `this.pingUrl` from MonitorService |

### PingResult Interface
[Source: netmonitor/src/app/models/ping-result.interface.ts]

```typescript
export interface PingResult {
  timestamp: Date;
  latencyMs: number | null;
  status: 'ok' | 'error';
}
```

**Note:** PingResult does not include `target` - this must come from MonitorService.pingUrl

### DatabaseService API Reference
[Source: netmonitor/src/app/services/database.service.ts]

```typescript
abstract class DatabaseService {
  protected readonly DB_NAME = 'netmonitor.db';
  readonly isInitialized$: Observable<boolean>;
  get isInitialized(): boolean;

  abstract init(): Promise<void>;
  abstract execute(sql: string, params?: unknown[]): Promise<void>;
  abstract select<T>(sql: string, params?: unknown[]): Promise<T[]>;
  abstract close(): Promise<void>;
}
```

### MonitorService Current Implementation
[Source: netmonitor/src/app/services/monitor.service.ts]

Key integration point - the subscribe block in `startMonitoring()`:

```typescript
.subscribe(result => {
    const current = this._results$.value;
    const updated = [...current, result].slice(-50);
    this._results$.next(updated);
    // ADD PERSISTENCE HERE - non-blocking
});
```

- `this.pingUrl` is the target address (private readonly, defaults to 'https://www.google.com')
- Results are kept in memory (last 50 points via BehaviorSubject)
- Uses `providedIn: 'root'` pattern

### Non-Blocking Persistence Pattern
[Source: architecture/coding-standards.md#async-operations]

```typescript
// Fire-and-forget pattern for non-blocking writes
// PingRepository handles errors internally, so no .catch() needed in MonitorService
this.pingRepository.savePing(result, this.pingUrl);
```

**CRITICAL:** Do NOT use `await` - this would block the next ping measurement.

### PingRepository Error Handling Design

Error handling is encapsulated **within PingRepository**, not MonitorService. This keeps MonitorService clean:

```typescript
// In PingRepository.savePing()
async savePing(result: PingResult, target: string): Promise<void> {
  if (!this.db.isInitialized) {
    return; // Skip if DB not ready (browser mode)
  }
  try {
    await this.db.execute(
      'INSERT INTO pings (timestamp, latency_ms, success, target) VALUES (?, ?, ?, ?)',
      [result.timestamp.getTime(), result.latencyMs, result.status === 'ok' ? 1 : 0, target]
    );
  } catch (err) {
    console.error('Failed to persist ping:', err);
    // Don't throw - monitoring continues regardless
  }
}
```

**Standard error message:** `'Failed to persist ping:'` (use this consistently)

### Error Handling Requirements
[Source: architecture/coding-standards.md#code-quality-rules]

- Never swallow errors silently - always log with `console.error()`
- Database failures must NOT crash the app or stop monitoring
- Monitoring functionality takes priority over persistence
- Graceful degradation: app works even if database is unavailable

### Platform Considerations
[Source: architecture/architecture-patterns-and-conventions.md#platform-detection-pattern]

- WebDatabaseService returns immediately (no-op) - persistence calls will succeed but data won't persist
- Check `databaseService.isInitialized` before attempting save to avoid unnecessary calls
- This is acceptable for browser dev mode

## Testing

### Test File Location
[Source: architecture/source-tree-and-module-organization.md]

- Test files co-located with source: `*.spec.ts`
- Create: `netmonitor/src/app/services/ping.repository.spec.ts`
- Update: `netmonitor/src/app/services/monitor.service.spec.ts`

### Testing Framework
[Source: architecture/testing-strategy.md]

- **Test Runner:** Vitest (via `@angular/build:unit-test`)
- **Browser Mode:** Chromium via Playwright
- **Commands:** `npm test` or `ng test --browsers=chromium`

### Test Structure Pattern
[Source: architecture/coding-standards.md#unit-test-structure]

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { TestBed } from '@angular/core/testing';

describe('PingRepository', () => {
  let repository: PingRepository;
  let mockDb: { execute: ReturnType<typeof vi.fn>; isInitialized: boolean };

  beforeEach(() => {
    mockDb = {
      isInitialized: true,
      execute: vi.fn().mockResolvedValue(undefined),
    };

    TestBed.configureTestingModule({
      providers: [
        PingRepository,
        { provide: DatabaseService, useValue: mockDb }
      ]
    });
    repository = TestBed.inject(PingRepository);
  });

  it('should call execute with correct SQL and params', async () => {
    const result: PingResult = {
      timestamp: new Date('2024-01-15T10:30:00Z'),
      latencyMs: 42.5,
      status: 'ok'
    };

    await repository.savePing(result, 'https://google.com');

    expect(mockDb.execute).toHaveBeenCalledWith(
      'INSERT INTO pings (timestamp, latency_ms, success, target) VALUES (?, ?, ?, ?)',
      [1705314600000, 42.5, 1, 'https://google.com']
    );
  });
});
```

### Mocking DatabaseService for MonitorService Tests

```typescript
// In monitor.service.spec.ts
let mockPingRepository: { savePing: ReturnType<typeof vi.fn> };
let mockDatabaseService: { isInitialized: boolean };

beforeEach(() => {
  mockPingRepository = {
    savePing: vi.fn().mockResolvedValue(undefined)
  };
  mockDatabaseService = {
    isInitialized: true
  };

  TestBed.configureTestingModule({
    providers: [
      MonitorService,
      { provide: PingRepository, useValue: mockPingRepository },
      { provide: DatabaseService, useValue: mockDatabaseService }
    ]
  });
});
```

### Coverage Target
[Source: architecture/testing-strategy.md]

- **Target:** 80% coverage on new services
- **Command:** `ng test --coverage`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-12 | 0.1 | Initial draft created from Epic 1 | Scrum Master |
| 2025-12-12 | 0.2 | PO validation: Merged error handling into Task 1, simplified Task 2, renumbered Tasks 3-5, added IV references to Task 5, standardized error message, added PingRepository design pattern | PO (Sarah) |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### File List
| File | Action | Description |
|------|--------|-------------|
| `netmonitor/src/app/services/ping.repository.ts` | Created | PingRepository service with savePing() method |
| `netmonitor/src/app/services/ping.repository.spec.ts` | Created | Unit tests for PingRepository (7 tests) |
| `netmonitor/src/app/services/monitor.service.ts` | Modified | Added PingRepository injection and fire-and-forget persistence call |
| `netmonitor/src/app/services/monitor.service.spec.ts` | Modified | Added PingRepository mock and 5 persistence integration tests |

### Debug Log References
None - implementation completed without issues.

### Completion Notes
- All unit tests pass (84/84)
- Lint passes with no errors
- Web build successful
- PingRepository implements non-blocking, fire-and-forget persistence pattern
- Error handling encapsulated within PingRepository (logs errors, never throws)
- Integration tests verify: results$ emission regardless of DB state, savePing called per ping, database errors don't stop monitoring, non-blocking write verification
- Tauri verification complete: 21 pings persisted to SQLite database at `~/.config/com.galvani.netmonitor/netmonitor.db`
- Database records verified with correct schema: id, timestamp (Unix ms), latency_ms (REAL), success (INTEGER 1/0), target (TEXT)

---

## QA Results

### Review Date: 2025-12-15

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation. The PingRepository service is clean, minimal (~40 lines), and follows the Single Responsibility Principle. The integration into MonitorService is non-intrusive (4 lines changed). Key highlights:

- **Repository Pattern**: Clean separation of persistence concerns from monitoring logic
- **Fire-and-Forget Pattern**: Non-blocking writes implemented correctly (no `await`)
- **Error Encapsulation**: All error handling within PingRepository, keeping MonitorService clean
- **Parameterized SQL**: No SQL injection risk
- **Graceful Degradation**: App works when database is unavailable (browser mode)

### Refactoring Performed

None required - implementation is clean and follows established patterns.

### Compliance Check

- Coding Standards: ✓ Uses `inject()` pattern, proper file naming, JSDoc documentation
- Project Structure: ✓ Files co-located in `services/` directory with tests
- Testing Strategy: ✓ 80%+ coverage target met; 12 new tests (7 unit + 5 integration)
- All ACs Met: ✓ All 5 acceptance criteria verified with tests

### Improvements Checklist

- [x] All implementation tasks completed
- [x] Unit tests cover all code paths (7 tests)
- [x] Integration tests verify non-blocking behavior (5 tests)
- [x] Manual Tauri verification completed
- [ ] Consider automated IV2/IV3 testing in future (memory usage, startup time)

### Security Review

**PASS** - No security concerns identified:
- Parameterized SQL queries prevent SQL injection
- No user input directly interpolated into queries
- Error messages don't leak sensitive information

### Performance Considerations

**PASS** - Non-blocking persistence pattern ensures:
- Ping timing unaffected by database writes
- Database errors don't delay monitoring
- Fire-and-forget calls prevent promise queue buildup

### Files Modified During Review

None - no refactoring was required.

### Gate Status

Gate: **PASS** → `docs/qa/gates/1.3-integrate-ping-persistence-into-monitorservice.yml`

### Recommended Status

**✓ Ready for Done** - All acceptance criteria met, tests passing, no blocking issues.
